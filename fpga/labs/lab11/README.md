# Lab 12 Instructions

In this lab we implement a **pseudo-random bit sequence (PRBS) generator** using a **Linear-Feedback Shift-Register (LFSR)**.

As a first step, open a terminal and go inside the `lab11/` directory :

```
% cd Desktop/lae/fpga/labs/lab11
```

Copy from the `.solutions/` directory the main `Makefile` already prepared for you :

```
% cp .solutions/Makefile .
```

Explore available targets :

```
% make help
```

Create a new fresh working area :

```
% make area
```

Additionally, copy from the `.solutions/` directory the following **Tcl simulation scripts** :


```
% cp .solutions/scripts/sim/compile.tcl    ./scripts/sim
% cp .solutions/scripts/sim/elaborate.tcl  ./scripts/sim
% cp .solutions/scripts/sim/simulate.tcl   ./scripts/sim
% cp .solutions/scripts/sim/run.tcl        ./scripts/sim
```

Create the main PRBS generator module `rtl/LFSR.v` with the following content :


```verilog
`timescale 1ns / 100ps

module LFSR (

   input  wire clk,      // assume 100 MHz input clock fed to "ticker"
   output wire PRBS      // output pseudo-random bit sequence

   ) ;


   /////////////////////////
   //   10 MHz "ticker"   //
   /////////////////////////

   wire enable ;

   TickCounter #(.MAX(10)) TickCounter_inst (.clk(clk), .tick(enable)) ;


   ////////////////////////////////////////
   //   linear feedback shift register   //
   ////////////////////////////////////////

   // seed
   reg [7:0] LFSR = 8'hFF ;       // what happens if we put 8'h00 ?


   wire feedback = LFSR[7] ;

   always @(posedge clk) begin

      if (enable) begin

         LFSR[0] <= LFSR[7] ;
         LFSR[1] <= LFSR[0] ;
         LFSR[2] <= LFSR[1] ^ feedback ; 
         LFSR[3] <= LFSR[2] ^ feedback ;
         LFSR[4] <= LFSR[3] ^ feedback ;
         LFSR[5] <= LFSR[4] ;
         LFSR[6] <= LFSR[5] ;
         LFSR[7] <= LFSR[6] ;

      end   // if
   end // always

   assign PRBS = LFSR[7] ;

endmodule
```

Copy remaining RTL and simulation sources from the `.solutions/` directory as follows :


```
% cp .solutions/rtl/TickCounter.v  ./rtl
% cp .solutions/bench/ClockGen.v   ./bench
% cp .solutions/bench/tb_LFSR.v    ./bench
```

Compile, elaborate and simulate the design with :

```
% make compile
% make elaborate
% make simulate
```

or simply type

```
% make sim
```

Observe the pseudo-random bit sequence generated by the circuit. Try to understand
the **repetition period** of the pseudo-random pattern.

A simple **PyROOT** script is available to plot the "trend" of bytes generated by the LFSR. Since the ASCII file `bytes.txt`
containing all bytes generated by the circuit is created  in the `work/sim` directory you have to copy and run the script
inside `work/sim` :


```
% cp .solutions/pyroot/histoBytes.py ./work/sim
% cd work/sim
% cat bytes.txt
% python -i histoBytes.py
``` 


## Exercise

Play with the "ticker" period and with the **seed** of the LFSR. What happens to the output pattern if the seed is `8'h00` ?

You can also see that the value `8'h00` is never reached. Modify the feedback in the LFSR in order to fix this :


```verilog
wire feedback = LFSR[7] ^ (LFSR[6:0] == 7'b0000000) ;  // this modified feedback allows reaching 256 states instead of 255
```

